 Co-routines are a fantastic part of Kotlin, and yet many Kotlin developers struggle to describe exactly what co-routines are. Often we focus on what they do, like async await and other background tasks. So in this video, we're going to put all of those things aside, and we're going to focus on what the essence of co-routines actually is. We're going to distill them down to their core characteristics. And by the end of this video, you'll understand what makes a co-routine a co-routine. So let's get started, not with co-routines, but with regular old functions, and examine how execution typically flows between different functions. Now here I've got two functions. In the main function, we're milking a few cows, and in the middle of all that, we're going to call another function where we feed some chickens. Now any developer who's been writing code for more than a day or two can tell you what the execution path is going to be for this code. We're going to milk two cows, and when we get to this function call, we'll move into the feed chickens function, and after this function runs, execution is going to return back to the main function here, and we finish milking the cows. And of course, we can verify this by running the code, which shows us exactly what we expect. We're milking two cows, feeding four chickens, and then milking two more cows. Okay, let's talk about this function call here when we call feed chickens. Now there are two sides to a function call. First is the entry, when the feed chickens function is invoked, execution is going to pass from main into feed chickens. And then there's the exit, which is when the feed chickens function completes, execution passes back from feed chickens into the main function again. When feed chickens is invoked, the state of the main function is still going to exist. So even though the execution moves over to the feed chickens function, this cow variable still exists. And the main function is just kind of paused waiting for the feed chickens to come back. So the feed chickens function to complete, and once it does, the cow variable will still have the same number in it. Now what about when the feed chickens function returns? Even though it's got this chicken variable, once the function returns, this variable is no longer going to exist. In other words, the state of this function is eliminated. Now I'm really just describing the properties of a call stack, right? When the main function starts, we've got a stack frame with a cow variable. And then when we call feed chickens, we get another frame on that stack. With the chicken variable, and then once that's done, that stack frame is popped off the top of the stack and its state vanishes. So a function call pauses the function and preserves its state, but a function return completes the function and eliminates its state. Now what if a function return could have similar properties to a function call? So in other words, what if a function could yield its execution back to its collar, like a return would, but also pauses its execution and preserves its state. As if it were making a function call. And this is the essence of a co-routine, the ability to pause its execution and preserve its state, not just when calling another function, but at any point. So let's look at a very simple example of a co-routine. Here we're still milking cows and feeding chickens, but instead of a regular function call to feed the chickens, we're feeding chickens within a co-routine. Now I've created a few helper functions here, like create co-routine, yield and complete. And then we're going to have a couple of different kinds of functions. And I did this to keep the example here clean. And in a moment, I'll reveal exactly what these functions are all doing, but for now, I just want us to focus on the execution flow. Now in the previous code listing, we milked two cows, and then we fed all four chickens, and then we came back and milked two more cows. But in this code, the execution is going to bounce back and forth between the two functions so that we'll milk a cow and then feed a chicken and then milk a cow and then feed a chicken and so on. So again, the big difference here is that this feed chickens is able to return execution back to its collar and pause its execution and preserve its state. Just like if it were making a function call, but instead of calling another function, it's returning the execution back to its collar. Now whereas our previous code fed all the chickens in one go, you can see this version interleaves the tasks of milking cows and feeding chickens. Now if you're like Mr. Grumpy or Calstrunt man, you might be saying, Dave, why the first code's not Conqueror's Nen if it was also milk and them cows and feed and them chickens. Well, our first code example with a regular function call, we were also milking cows and feeding chickens. So I guess you could say we were doing two tasks over a period of time, but a diagram of that work would look like this where all of the chickens are fed at once. In order to be considered concurrent, we need to be able to do that. We'll be able to bounce back and forth between the tasks, doing a little bit of each task each time. Now like I said earlier, to keep the example clean, I've omitted a small amount of implementation here, but just to put all of my cards on the table, let's see what I've been hiding from you. We've got four functions here. And the first is the CreateCodeRoutine function. And this one I created as just kind of a wrapper around an extension function with a similar name. So let's use refactoring tools to outline this function call. Since CreateCodeRoutine uninterested is an extension function on a suspend function, we're going to need to also make sure we add the suspend modifier before this block. Okay, next, this resume function is just a shortcut for resuming with a unit, and we can easily inline that as well. That just leaves two more yield and complete, which are both shortcuts to a function named suspendCodeRoutine. When the lambda that we pass to this function evaluates to this special co-routine suspended value, then the co-routine is going to be paused. Otherwise, we can just invoke resume inside this block to finish it out. So here it is with no hidden implementation. Note that we haven't used async or launch or run blocking. We haven't referenced any dispatchers. We've not dealt with any jobs or deferred. And in fact, this project doesn't even depend on the cotlonex.co routines library. So we're calling some very low level functions that we normally probably wouldn't call from our application code directly. But by doing that, we've gotten to see the essence of what co-routines actually is. Building upon this foundation, there are lots of ways we can apply co-routines, including things like sequence generators, deeper cursion, running code simultaneously, async away, and a whole lot more. And between the standard library and the cotlonex.co routines library, we get all of those features. But as we've seen, the essence of co-routines is actually quite simple. If you're looking for more information about co-routines, Chapter 20 of Kotlin and Illustrated Guide covers the most important concepts that you need to know about co-routines in order to be effective with them day to day. If you've purchased the lean pub edition of the book, then you've got early access to a draft of Chapter 20 right now. If you'd like to pick up the book, you can get it at book.typealius.com. Or if you'd rather, of course, you can just wait until it lands in the online edition of the book, which will probably happen sometime around the end of June. Also, you should join hundreds of other Kotlin developers who have signed up for my new email newsletter, where you can get the inside scoop about any new articles, videos, and other fun projects that I'm working on. Thanks so much for hanging out with me today, and I will see you next time. I'm Eric BDS Software, and get early access to new chapters at their rip. You can pick up your copy today. Just go to book.typealius.com.